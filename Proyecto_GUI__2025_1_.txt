Pontificia Universidad Cat´olica de Chile
Escuela de Ingenier´ıa
Departamento de Ciencia de la Computaci´on
IIC2113 Dise˜no Detallado de Software

Entrega 3: Shin Megami Tensei (Interfaz Gr´afica)

Francisco Ignacio Gazit´ua Requena
Cristian Andr´es Hinostroza Espinoza

Introducci´on

La librer´ıa Shin Megami Tensei GUI incluye una clase, 5 interfaces y una enumeraci´on:

SMTGUI es una clase que te permitir´a abrir una ventana y cambiar lo que aparece en ella.

IUnit es una interfaz con m´etodos para obtener la informaci´on de la unidad (e.j. su nombre, HP, etc).

IPlayer es una interfaz con m´etodos para obtener la informaci´on de un jugador, como las unidades en
el tablero y la reserva.

IState es una interfaz con m´etodos para obtener la informaci´on del juego, como las opciones que tiene
disponible para elegir el jugador, la cantidad de turnos, etc.

ITeamInfo es una interfaz con m´etodos para obtener la informaci´on de un equipo, como el nombre del
samurai y los demonios.

IClickedElement es una interfaz con m´etodos para obtener la informaci´on del ´ultimo elemento que se
le hizo click en la ventana, como el texto y qu´e jugador estaba ligado.

ClickedElementType es una enumeraci´on que tiene los distintos tipos de elementos que puede ser
IClickedElement.

Para utilizar la librer´ıa, puedes comenzar desde la nueva versi´on del c´odigo base o seguir las instrucciones
descritas en el Ap´endice A

1.

Interfaces IState, IPlayer y IUnit

Cualquier clase que implemente la interfaz IState tendr´a que implementar estos m´etodos:

1 public interface IState {
2

public IPlayer Player1 { get ; }
public IPlayer Player2 { get ; }
public IEnumerable < string > Options { get ; }
public int Turns { get ; }
public int BlinkingTurns { get ; }
public IEnumerable < string > Order { get ; }

3

4

5

6

7
8 }

El m´etodo void Update(IState state) de la clase SMTGUI recibe un objeto que implemente IState, por
lo tanto, para utilizar este m´etodo, tendr´as que tener una clase en tu c´odigo que la implemente.

Dado que IState tiene las properties Player1 y Player2 tendr´as que tener una clase que implemente dicha
interfaz, la cual expone los siguientes m´etodos:

1

1 public interface IPlayer
2 {
3

IUnit ?[] UnitsInBoard { get ; }
IEnumerable < IUnit > UnitsInReserve { get ; }

4
5 }

De igual forma, tendr´as que tener alguna clase que implemente la interfaz IUnit, la cual expone los siguientes
m´etodos:

1 public interface IUnit
2 {
3

string Name { get ; }
int HP { get ; }
int MP { get ; }
int MaxHP { get ; }
int MaxMP { get ; }

4

5

6

7
8 }

2.

Interfaz ITeamInfo

La interfaz ITeamInfo expone los siguientes m´etodos:

1 public interface ITeamInfo
2 {
3

string SamuraiName { get ; }
string [] SkillNames { get ; }
string [] DemonNames { get ; }

4

5
6 }

No es necesario que crees clases que implementen esta interfaz, ya que esta interfaz s´olo es utilizada
como retorno del m´etodo ITeamInfo GetTeamInfo(int playerId) de la clase SMTGUI.

3.

Interfaz IClickedElement

La interfaz IClickedElement expone los siguientes m´etodos:

1 public interface IClickedElement
2 {
3

string Text { get ; }
int ? PlayerId { get ; }
C li c k e d E l em en t Ty p e Type { get ; }

4

5
6 }

No es necesario que crees clases que implementen esta interfaz, ya que esta interfaz s´olo es utilizada
como retorno del m´etodo IClickedElement GetClickedElement() de la clase SMTGUI.

Cabe destacara que Type retorna una instancia de tipo ClickedElementType, el cual es una enumeraci´on
que contiene los siguientes miembros:

1 public enum Cl i ck ed E le m en tT y pe
2 {
3

UnitInBoard ,
UnitInReserve ,
Button ,

4

5
6 }

2

4. Clase SMTGUI

Como se dijo anteriormente, esta clase permite abrir una ventana y actualizar su contenido. Para abrir una
ventana, primero se crea un objeto del tipo SMTGUI y luego se llama el m´etodo Start(...).

void Start(Action startProgramCallback): Este m´etodo inicia una ventana y luego invoca startProgramCallback.
Notar que el par´ametro startProgramCallback es de tipo Action. Este es un tipo de dato utilizado
para encapsular funciones que no retornan nada y que no reciben argumentos.

Ocurre que MacOS no permite crear ventanas desde threads que no sean el principal del programa. Esto
nos obliga a que, luego de creada la ventana, esa ventana se quede con el thread principal de la apli-
caci´on (y no lo suelta hasta que la ventana se cierra). Para que tu programa siga funcionando, noso-
tros invocamos startProgramCallback desde el thread secundario. Por lo mismo, considera que cuando
llames a Start(Action startProgramCallback) tu c´odigo continuar´a desde el m´etodo encapsulado en
startProgramCallback.

Por ejemplo, este Program.cs abre la ventana y luego llama a Main() - que no hace nada.

1 using S h i n _ M e g a m i _ T e n s e i _ G U I ;
2
3 SMTGUI gui = new SMTGUI () ;
4 gui . Start ( Main ) ;
5
6 void Main () {
7
8 }

// Por ahora , no hace nada .

Si corres este programa se abre una ventana que permite elegir el equipo. Pero dado que el m´etodo Main
est´a vac´ıo, no ocurre nada al apretar el bot´on “Seleccionar equipo”.

Para obtener el equipo ingresado por el usuario, puedes utilizar el m´etodo:

ITeamInfo GetTeamInfo(int playerId): Retorna un objeto de tipo ITeamInfo (ver Secci´on 3) con
la informaci´on elegida por el usuario. El argumento playerId sirve para mostrar en la ventana cu´al es
el jugador que est´a seleccionando el equipo.

Por ejemplo, este c´odigo abre una ventana y pide a ambos jugadores que seleccionen sus equipos y luego,
muestra la informaci´on en consola.

3

1 using S h i n _ M e g a m i _ T e n s e i _ G U I ;
2
3 var gui = new SMTGUI () ;
4 gui . Start ( Main ) ;
5
6 void Main () {
7

8

9

ITeamInfo team1 = gui . GetTeamInfo (1) ;
ShowTeamInfo ( team1 ) ;
ITeamInfo team2 = gui . GetTeamInfo (2) ;
ShowTeamInfo ( team2 ) ;

10
11 }
12
13 void ShowTeamInfo ( ITeamInfo team )
14 {
15

Console . WriteLine ( $ " Samurai : { team . SamuraiName } " ) ;
Console . WriteLine ( " Skills : " ) ;
foreach ( var skill in team . SkillNames )

Console . WriteLine ( skill ) ;
Console . WriteLine ( " Demons : " ) ;
foreach ( var demon in team . DemonNames )

Console . WriteLine ( demon ) ;

16

17

18

19

20

21
22 }

Al ejecutar este c´odigo, el programa se quedar´a en la l´ınea 7 esperando hasta que el primer jugador presione
“Seleccionar equipo”. En ese momento, GetTeamInfo(...) retornar´a un objeto del tipo ITeamInfo que
contiene la informaci´on seleccionada por el jugador.

En este caso, presionar “Seleccionar equipo” har´a
que el m´etodo ShowTeamInfo(...) imprima esto
en consola:

1 Samurai : Kyouji
2 Skills :
3 Gather Spirit Energy
4 High Fire Pleroma
5 Demons :
6 Gurulu
7 Hel

Una vez seleccionados los equipos, hay dos m´etodos que podr´ıan ser de inter´es:

void ShowEndGameMessage(string message): Muestra message en la ventana. Este m´etodo puede
servir para mostrar que la selecci´on fue inv´alida, para mostrar que un jugador se rindi´o o para mostrar
que un jugador gan´o el juego.

void Update(IState state): Actualiza el contenido de la ventana en base a state, en particular,
muestra la vista principal del juego (tablero, unidades en reserva, opcciones, etc.).

4

Como se mencion´o anteriormente, para poder utilizar el m´etodo Update(...) es necesario crear clases que
implementen las interfaces que utiliza este m´etodo. Supongamos que creamos las siguientes clases1:

1 public class Unit ( string name , int hp , int mp , int maxHp , int maxMp )
2
3 {
4

: IUnit

public string Name { get ; } = name ;
public int HP { get ; set ; } = hp ;
public int MP { get ; set ; } = mp ;
public int MaxHP { get ; } = maxHp ;
public int MaxMP { get ; } = maxMp ;

5

6

7

8
9 }

1 public class Player ( IUnit ?[] unitsInBoard , IEnumerable < IUnit > unitsInReserve ) : IPlayer
2 {
3

public IUnit ?[] UnitsInBoard { get ; } = unitsInBoard ;
public IEnumerable < IUnit > UnitsInRes erve { get ; set ; } = unitsInReserve ;

4
5 }

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

8

9

10

11

12

13

14

15

1 public class State : IState
2 {
3

public IPlayer Player1 { get ; set ; }
public IPlayer Player2 { get ; set ; }

public IEnumerable < string > Options { get ; set ; } =
[

" Atacar " ,
" Disparar " ,
" Usar Habilidad " ,
" Invocar " ,
" Rendirse "

];

public int Turns { get ; set ; } = 2;
public int BlinkingTurns { get ; set ; } = 7;

public IEnumerable < string > Order { get ; set ; } =
[

" Flynn " ,
" Joker " ,
" Alice " ,

];

23
24 }

Ahora, en el Program.cs creamos una instancia de State cualquiera, ignorando los equipos seleccionado por
el usuario:

1 using S h i n _ M e g a m i _ T e n s e i _ G U I ;
2
3 var gui = new SMTGUI () ;
4 gui . Start ( Main ) ;
5
6 void Main () {
7

ITeamInfo team1 = gui . GetTeamInfo (1) ;
ITeamInfo team2 = gui . GetTeamInfo (2) ;
var flynn = new Unit ( " Flynn " , 100 , 50 , 120 , 50) ;
var joker = new Unit ( " Joker " , 100 , 50 , 100 , 50) ;
var alice = new Unit ( " Alice " , 100 , 50 , 100 , 70) ;
var ares = new Unit ( " Ares " , 100 , 50 , 100 , 70) ;
var centaur = new Unit ( " Centaur " , 100 , 50 , 100 , 70) ;
var gnome = new Unit ( " Gnome " , 100 , 50 , 100 , 70) ;
var knocker = new Unit ( " Knocker " , 100 , 50 , 100 , 70) ;

1En este ejemplo, el orden y las opciones est´an hardcodeados. En la pr´actica, no deber´ıa ser as´ı

5

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

var player1 = new Player (

[

] ,
[

]

flynn ,
null ,
alice ,

ares ,
centaur ,

) ;
var player2 = new Player (

[

] ,
[

]

joker ,

gnome ,
knocker

) ;

var state = new State
{

Player1 = player1 ,
Player2 = player2 ,

};

gui . Update ( state ) ;

44
45 }

Este c´odigo mostrar´a las ventanas para elegir los equipos y luego mostrar´a esta ventana:

6

Desde esta ventana podemos interactuar con todos los botones (Button), unidades en el tablero (UnitInBoard)
y unidades en reserva (UnitInReserve).

Para poder obtener informaci´on del usuario puedes utilizar el m´etodo GetClickedElement(), el cual retorna
una instancia de IClickedElement, el cual adem´as de contener el tipo de elemento seleccionado (Type),
retorna informaci´on como el contenido del elemento seleccionado (Text) y, en caso de que el elemento no sea
Button contiene el PlayerId relacionado (para diferenciar unidades que tengan el mismo nombre).

Cabe destacar que GetClickedElement(...) espera a que el usuario haga click en alg´un elemento y retorna.
Por lo tanto, su retorno nunca ser´a null. Por otro lado, dado que en ocasiones ustedes querr´an que el usuario
seleccione ciertos elementos, probablemente necesitar´an algo de este estilo:

1 IClic ke d El ement clickedElement ;
2 do {
3
4 } while (!( clickedElement . Type == C li c ke d E l em e nt Ty p e . Button && clickedElement . Text == "

clickedElement = gui . G etCl i ck e dE l em e nt () ;

Atacar " ) ) ;

Este bucle s´olo se romper´a cuando el elemento retornado por GetClicledElement cumpla las condiciones
correspondientes.

7

Por ejemplo, si modificamos el m´etodo Main() mostrado anteriormente, y le agregamos las siguientes l´ıneas:

1 IClic ke d El ement clickedElement ;
2 do {
3
4 } while (!( clickedElement . Type == C li c ke d E l em e nt Ty p e . Button && clickedElement . Text == "

clickedElement = gui . G etCl i ck e dE l em e nt () ;

Atacar " ) ) ;

flynn . HP -= 10;

clickedElement = gui . G etCl i ck e dE l em e nt () ;

5
6 do {
7
8 } while ( clickedElement . Type != Cl i ck ed E le me n tT y p e . UnitInBoard ) ;
9
10 if ( clickedElement . Text == " Flynn " )
11
12 else if ( clickedElement . Text == " Joker " )
13
14 else if ( clickedElement . Text == " Alice " )
15
16 flynn . MP -= 10;
17 state . Turns - -;
18
19 gui . Update ( state ) ;

joker . HP -= 10;

alice . HP -= 10;

Luego de dar click en “Atacar” y en alguna de las 3 unidades en el tablero, el tablero se actualizar´a.
Suponiendo que le dimos click a Alice, la vista se ver´a as´ı:

Cabe destacar que si se da click en alg´un elemento distinto al bot´on “Atacar”, el programa se quedar´a en el
primer bucle. Esto te servir´a para garantizar que no pase nada si el usuario selecciona un elemento incorrecto.

8

Consideraciones para la entrega

Cuando agregues la interfaz gr´afica a tu entrega, debes cumplir con los siguientes requerimientos:

Se puede elegir un equipo a ambos jugadores.

Si alguno de los equipos es inv´alido, se muestra el mensaje de que el equipo es inv´alido.

Si ambos equipos son v´alidos, se muestra la ventana con ambos equipos junto sus stats (HP y MP), el
orden inicial, la cantidad de turnos correspondientes y las opciones correspondientes a la unidad inicial.

Se permite realizar todas las acciones disponible para cada unidad, como atacar, disparar, etc.

Durante el juego se actualiza correctamente la ventana en base a las acciones del usuario, como el
movimiento de unidades entre el tablero y la reserva, la actualizaci´on de stats, turnos, etc.

Al finalizar el juego, se felicita al equipo que gana.

9

A.

¿C´omo agregar la librer´ıa a mi proyecto?

Para agregar la librer´ıa a un proyecto existente debes realizar los siguientes pasos. Primero, abre NuGet
desde Rider e instala las librer´ıas Avalonia, Avalonia.Desktop y Avalonia.Themes.Fluent en el proyecto
Shin-Megami-Tesei-View:

Pon la carpeta GuiLib dentro del proyecto Shin-Megami-Tensei-View. Luego en Dependencies selecciona
que quieres agregar una referencia mediante “Add From...”

Aparecer´a un men´u con las carpetas de tu computador. Anda hasta la carpeta GuiLib dentro de tu pro-
yecto Shin-Megami-Tensei-View y selecciona Shin-Megami-Tensei-GUI.dll. Repite el proceso para el
proyecto Shin-Megami-Tensei-Controller. Si seguiste los pasos correctamente, podr´as ver que la librer´ıa
Shin-Megami-Tensei-GUI fue agregada a las dependencias de los proyectos Controller y View.

Finalmente, puedes verificar que la librer´ıa fue importada utilizando el siguiente c´odigo (en tu Program.cs):

10

1 using S h i n _ M e g a m i _ T e n s e i _ V i e w ;
2 using S h i n _ Me g am i _T en s ei ;
3 using S h i n _ M e g a m i _ T e n s e i _ G U I ;
4

5
6 var gui = new SMTGUI () ;
7 gui . Start ( Main ) ;
8
9 void Main () {}

Al correr ese c´odigo deber´ıa aparecer la siguiente ventana:

B.

¿C´omo incluyo la interfaz sin echarme los test cases?

Comencemos desde una entrega que implementa MVC. Como ejemplo, utilicemos una entrega que permite
elegir el archivo de equipos y luego, arbitrariamente, dice que el equipo es inv´alido.

1 public class Game {
2

private readonly S h i n M e g a m i T e n s e i V i e w _view ;
private readonly string _teamsFolder ;

public Game ( View view , string teamsFolder ) {

_view = new Fir eEmblemView ( view ) ;
_teamsFolder = teamsFolder ;

}

public void Play () {

string teamFile = _view . Sele ctTeamFile (

_teamsFolder ) ;

_view . A n n o u n c e T h a t T e a m I s I n v a l i d () ;

3

4

5

6

7

8

9

10

11

12

}

13
14 }

11

El objetivo es agregar la interfaz gr´afica sin echar a perder los test cases. Lo primero es notar que Game usa
como vista ShinMegamiTenseiView. Esta clase se encuentra en el proyecto de la vista, e incluye el siguiente
c´odigo:

1 public class S h i n M e g a m i T e n s e i V i e w ( View view ) {
2

public void A n n o u n c e T h a t T e a m I s I n v a l i d ()

3

4

5

6

7

= > view . WriteLine ( " Archivo de equipos inv ´a lido " ) ;

public string SelectTeamFile ( string teamsFolder ) {

Te amS ele ctio nVi ew t eamS ele cti onV iew = new ( view , teamsFolder ) ;
return te amS ele cti onVi ew . SelectTeamFile () ;

}

8
9 }

B´asicamente, tiene un m´etodo para anunciar que el equipo es inv´alido y otro para mostrar el men´u que
permite seleccionar al equipo. Notar que la clase ShinMegamiTenseiView es nuestra vista consola. Contiene
m´etodos que, mediante la consola, muestran mensajes y reciben inputs. Al mismo tiempo, esta clase permite
que funcionen los test cases pues interact´ua con el View utilizado para testear el proyecto.

Para poder cambiar al modo interfaz gr´afica tenemos que crear una nueva vista. La nueva vista deber´ıa tener
los mismos m´etodos que ShinMegamiTenseiView, pero al elegir equipos y mostrar mensajes se deber´ıa hacer
mediante la interfaz gr´afica. De esa forma, el mismo controlador podr´a funcionar con ambas vistas.

Partamos creando una interfaz con los m´etodos comunes a todas las vistas que el controlador podr´a utilizar.

1 public interface I S h i n M e g a m i T e n s e i V i e w {
2

void A n n o u n c e T h a t T e a m I s I n v a l i d () ;
string SelectTeamFile ( string teamsFolder ) ;

3
4 }

Ahora hacemos que nuestra vista actual implemente la interfaz (y aprovechamos de cambiarle el nombre):

1 public class S h i n M e g a m i T e n s e i V i e w ( View view ) : I S h i n M e g a m i T e n s e i V i e w {
2

public void A n n o u n c e T h a t T e a m I s I n v a l i d ()

3

4

5

6

7

= > view . WriteLine ( " Archivo de equipos inv ´a lido " ) ;

public string SelectTeamFile ( string teamsFolder ) {

Te amS ele ctio nVi ew t eamS ele cti onV iew = new ( view , teamsFolder ) ;
return te amS ele cti onVi ew . SelectTeamFile () ;

}

8
9 }

Finalmente, hacemos que Game ahora funcione con cualquier vista que implemente nuestra interfaz:

1 public class Game {
2

private readonly I S h i n M e g a m i T e n s e i V i e w _view ;
private readonly string _teamsFolder ;

3

4

5

6

7

8

9

10

11

12

public Game ( View view , string teamsFolder ) {

_view = new FireEmblemView ( view ) ;
_teamsFolder = teamsFolder ;

}

public void Play () {

string teamFile = _view . SelectTeamF ile ( _teamsFolder ) ;
_view . A n n o u n c e T h a t T e a m I s I n v a l i d () ;

}

13
14 }

En el proyecto Shin-Megami-Tensei-View, agregamos una nueva vista para la interfaz gr´afica:

12

1 public class S h i n M e g a m i T e n s e i G u i V i e w : I S h i n M e g a m i T e n s e i V i e w {
2

private SMTGUI _window = new () ;

3

4

5

6

7

8

9

10

11

12

public void Start ( Action startProgram )
= > _window . Start ( startProgram ) ;
public void A n n o u n c e T h a t T e a m I s I n v a l i d ()

= > _window . S ho w En d Ga me M es s ag e ( " Al menos un equipo es inv ´a lido " ) ;

public string SelectTeamFile ( string teamsFolder ) {
ITeamInfo team1 = _window . GetTeamInfo (1) ;
ITeamInfo team2 = _window . GetTeamInfo (2) ;
return Te amI nfo For matt er . FormatTeamInfo ( team1 , team2 ) ;

}

13
14 }

Gracias a que esta vista tambi´en implementa ShinMegamiTenseiView, Game podr´a usarla sin problemas.
Aunque, para que ello ocurra, tenemos que crear un objeto ShinMegamiTenseiGuiView. La forma m´as
simple de hacer esto, sin tener que cambiar los test cases, es creando un segundo constructor para Game.

}

18
19 }

Finalmente, en el Program.cs podemos decidir si comenzamos en modo consola o en modo interfaz gr´afica
dependiendo del constructor que usemos.

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

9

10
11 }
12 else
13 {
14

15

16

17

18

19

20

21
22 }

1 public class Game {
2

private readonly I S h i n M e g a m i T e n s e i V i e w _view ;
private readonly string _teamsFolder ;

public Game ( View view , string teamsFolder ) {

_view = new FireEmblemView ( view ) ;
_teamsFolder = teamsFolder ;

}

public Game ( S h i n M e g a m i T e n s e i G u i V i e w view ) {

_view = view ;
_teamsFolder = " " ;

}

public void Play () {

string teamFile = _view . SelectTeamF ile ( _teamsFolder ) ;
_view . A n n o u n c e T h a t T e a m I s I n v a l i d () ;

1 using S h i n _ M e g a m i _ T e n s e i _ G U I ;
2 using S h i n _ M e g a m i _ T e n s e i _ V i e w ;
3 using S h i n _ Me g am i _T en s ei ;
4
5 bool useGui = true ;
6 if ( useGui )
7 {
8

S h i n M e g a m i T e n s e i G u i V i e w view = new () ;
Game game = new Game ( view ) ;
view . Start ( game . Play ) ;

string testFolder = SelectT es tF ol de r () ;
string test = SelectTest ( testFolder ) ;
string teamsFolder = testFolder . Replace ( " - Tests " ," " ) ;
An no un ceTestCase ( test ) ;

var view = View . B u i l d M a n u a l T e s t i n g V i e w ( test ) ;
var game = new Game ( view , teamsFolder ) ;
game . Play () ;

13

